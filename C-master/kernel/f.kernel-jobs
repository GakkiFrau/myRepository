==============================================================================

内核任务
--------


内核是在硬件与软件之间的一个中间层。其作用是将应用程序的请求传递给硬件，并充当
底层驱动程序，对系统中的各种设备和组件进行寻址。

从应用程序的视角来看，应用程序朱旭发送传输数据的命令。实际的工作如何完成与应用
程序是不相干的，因为内核抽象了相关的细节。应用程序与硬件本身没有联系，至于内核
有联系，内核是应用程序所知道的层次结构中最底层。

当若干程序在统一系统中并发运行时，也可以将内核视为资源管理程序。在这种情况下，
内核负责将可用共享资源（包括CPU时间，磁盘空间，网络连接等）分配到各个系统进程，
同时还需要保证系统的完整性。


内核种类
--------


微内核：只有最基本的功能直接有中央内核（即微内核）实现。所有其他的功能都委托给
一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。如，独立进程可能负
责实现各种文件系统，内存管理等。

宏内核：内核的全部代码，包括所有子系统（如内存管理，文件系统，设备驱动程序）都
打包到一个文件中。内核中的每个函数都可以访问内核中所有其他部分。linux便是采用
宏内核的方式，但在系统运行中，模块可以插入到内核代码中，也可以移除，这使得可以
向内核动态添加功能，弥补了宏内核的一些缺陷。


进程
----


由于Linux是多任务系统，它支持（看上去）并发执行的若干进程。系统中同时真正在运
行的进程数目最多不超过CPU数目，因此内核会按照短的时间间隔在不同的进程之间切换
（用户是注意不到的）。内核借助于CPU的帮助，负责进程之间进行切换。内核还必须确
定如何在在现存进程之间共享CPU时间。重要进程得到的CPU时间多一点，次要进程得到的
少一点，确定那个进程运行多长时间的过程称为调度。

linu对进程采用了一种层次系统，每个进程都依赖于一个父进程。内核启动init程序作为
第一进程，该进程负责进一步的系统初始化操作，因此init是进程树的根，所有的进程都
直接或间接起源自该进程。

创建新进程的两种机制：fork和exec

fork可以创建当前进程的一个副本，父进程和子进程只有PID（进程ID）不同。linux使用
了一种叫做写时复制（copy on write）的级数来是fork操作更高效，主要的原理是将内
存复制操作延迟到父进程或子进程向某内存页面写入数据之前，在只读访问的情况下父进
程和子进程可以公用同一内存页。

exec是将一个新程序加载到当前进程的内存中并执行。旧程序的内存页将刷出，其内容将
替换为新的数据。然后开始执行新程序。

线程：本质上一个进程可能有若干线程组成，这些线程共享同样的数据和资源，但可能执
行程序中不同的代码路径。线程通常也称为轻量级进程。

linux用clone方法创建线程。其工作方式类似与fork，但启用了精确的检查，以确认哪些
资源与父进程共享，哪些资源为线程独立创建。这种细粒度的资源分配扩展了一般的线程
概念，在一定成都上允许线程与进程之间的连续转换。

命名空间：linux中对命名空间的支持被集成到了许多子系统中。这使得不同的进程可以
看到不同的系统视图。如linux进程ID中有唯一表示的全局变量，启用命名空间之后，以
前的全局资源可以具有不同的分组。每个命名空间可以包含一个特定的PID集合，或可以
提供文件系统的不同视图，在某个命名空间中挂载的卷不会传播到其他命名空间中。现在
最大的用处莫过于在容器上的应用了，人们不必在为每个用户准备一台物理计算机，而是
通过称为容器的命名空间建立系统的多个视图。从容器内部看来这是一个完整的linux系
统，而且与其他容器没有交互，这样事实上一台物理机器可以同时运转许多这个的容器实
例，有助于更有效地使用资源。与完全虚拟化解决方案（如KVM）相比，计算机上只需要
运行一个内核来管理所有的容器。


内存管理
--------


地址空间的最大长度与实际可用的物理内存数量无关，这被称为虚拟地址空间。

2^10byte=1Kib 2^20byte=1Mib 2^30byte=1Gib 
由于内存区域是通过指针寻址，因此对于32位系统是2^32byte=4Gib，对64位是2^64byte。

linux将虚拟地址空间划分为两个部分，分别称为内核空间和用户空间。
0到TASK_SIZE是用户进程的虚拟地址范围。
TASK_SIZE到2^32或2^64是内核空间。
TASK_SIZE是一个特定与计算机体系结构的常数，如对于32位系统能够寻址的虚拟地址空
间为4Gib，TASK_SIZE常数是3Gib处，用户空间为0-3Gib，内核空间为3-4Gib。这种划分
与可用的内存数量无关。由于地址空间虚拟化的结果，每个用户进程都认为自身有3Gib的
内存，各个系统进程的用户空间是完全彼此分离的，而虚拟地址空间顶部的内核空间总是
同样的，这样内核的地址空间总是不会和用户地址空间混在一起，这样用户态和内核态之
间的分离的这种机制可防止进程无意间修改彼此的数据而造成相互干扰。

从用户状态到核心态的切换通过系统调用的特定手段完成。
普通进程只能借助于系统调用向内核发出请求，内核首先检查进程是否允许执行想要的操
作，然后代表进程执行所需的操作，接下来返回到用户状态。

虚拟地址如何映射到物理地址上呢？一一对应，显然不行。
内核将地址空间划分为很多等长的部分，这些部分称之为页。这样虚拟地址空间和物理地
址空间都能够用同样大小的页来表示，通过页来产生一一对应的关系，这样虚拟地址空间
就能和物理地址空间映射到一起。由于内核负责将虚拟地址空间映射到物理地址空间，因
此可以决定那些内存区域在进程之间共享，那些不共享，这样在内核的管控下，内核空间
和用户空间的进程内存仍然是分离的，不会造成混乱。

用来将虚拟地址空间映射到物理地址空间的数据结构称为页表。为减少页表的大小并容许
忽略不需要的区域，linux将虚拟地址划分成几部分，采用四级页表的管理方式，如同用
树形的数据结构可以快速寻找到自己所需要的内存块，如果你知道算法是怎么一回事的话，
这里应该很容易理解，如果有困难的话，自己做一下功课，这里不打算展开讲。

每次访问内存时，必须逐级访问多个数组才能将虚拟地址转换为物理地址，CPU则使用如
下的方法来加速该过程：
1）CPU中有一个专门的部分称为MMU（Memory Management Unit，内存管理单元），该单
元优化了内存访问操作。
2）地址转换中出现最频繁的那些地址，保存到称为地址转换后备缓冲器（TLB）的CPU高
速缓存中。无需访问内存中的页表即可从高速缓存直接获得地址数据。

内核在实现设备驱动程序时直接使用了内存映射。外设的输入/输出可以映射到虚拟地址
空间的区域中。对相关内存区域的读写会由系统重定向到设备，因而大大简化了驱动程序
的实现。

伙伴系统：内核中很多时候要求分配连续页。为快速检测内存中的连续区域，内核使用了
一种叫做伙伴系统。
系统中的空闲内存块总是两两分组，每组中的两个内存块称为伙伴。伙伴的分配可以是彼
此独立的。但如果两个伙伴都是空闲的，内核会将其合并为一个更大的内存块，作为下一
层上某个内存块的伙伴。
内核对所有大小相同的伙伴，都防止到同一个列表中管理。
例如：如果系统想在需要8个页帧，则将16个页帧组成的块拆分为两个伙伴。其中一块用
与满足应用程序的请求，而剩余的8个页帧则放置到对应8页大小内存块的列表中。

slab缓存：伙伴系统作为一种在使用比页帧大的内存的一种解决办法，但是，内核本身经
常需要比完整页帧小的多的内存块时就是一个问题了。这时，内核将伙伴系统提供的页划
分为更小的部分，还对频繁使用的小对象实现了一个一般性的缓存（slab缓存）。
slub则是slab的一个替代品，但是slub完全兼容slab。slub的效率更高更简单。

页面交换：页面交换通过利用磁盘空间作为扩展内存，从而增大了可用的内存。在内核需
要更多内存时，不经常使用的页可以写入硬盘，如果再需要访问相关数据，内核会将相应
的页切换回内存。

页面回收用于将内存映射被修改的内容与底层的块设备同步，有时也称为数据回写。


系统调用
--------


系统调用是用户进程与内核交互的方法。传统的系统调用按不同类别分组，如下：

进程管理：创建新进程，查询信息，调试。
信号：发送信号，定时器以及相关处理机制。
文件：创建，打开和关闭文件，从文件读取和向文件写入，查询信息和状态。
目录和文件系统：创建，删除和重命名目录，查询信息，链接，变更目录。
保护机制：读取和变更UID/GID，命名空间的处理。
定时器函数：定时器函数和统计信息。



设备驱动
--------


设备驱动程序用于与系统连接的输入/输出装置通信，如硬盘，声卡，各种接口等，UNIX
中的一切皆为文件（everything is a file），对外设的访问可利用/dev目录下的设备文
件来完成，程序对设备的处理完全类似与常规的文件。设备驱动程序的任务在与支持应用
程序经由设备文件与设备通信。就是，是的能够按适当的方式在设备上读取/写入数据。

字符设备：提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。此类设备
支持按字节/字符来读写数据。调制解调器是典型的字符设备。

块设备：应用程序可以随机访问设备数据，程序可自行确定读取数据的位置。硬盘是典型
的块设备，应用程序可以寻址磁盘上的任何位置，并由此读取数据，另外，数据的读写只
能以块（通常是512B）的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。

编写块设备的驱动程序比字符设备要复杂得多，因为内核为提高系统性能广泛地使用了缓
存机制。


网络
----


网卡也可以通过设备驱动程序控制，但在内核中属于特殊状况，因为网卡不能利用设备文
件访问。原因在于在网络通信期间，数据打包到了各种协议层中。在接收到数据时，内核
必须针对个协议层的处理，对数据进行拆包与分析，然后才能将有效数据传递给应用程序。
在发送数据时，内核必须首先根据各个协议层的要求打包数据，然后才能发送。

为支持通过文件接口处理网络连接，linux使用了源于BSD的套接字抽象。套接字可以看作
应用程序，文件接口，内核的网络实现之间的代理。


文件系统
--------


文件系统使用目录结构组织存储数据，并将其他元信息（例如所有者，访问权限等）与实
际数据关联起来。

linux系统中支持各种各样的文件系统，这些文件系统的功能各不相同，这得益于linux提
供一个额外的软件层（VFS，Virtual Filesystem，虚拟文件系统），将各种底层文件系
统的的具体特性与应用层隔离开来。

VFS既是向下的接口（所有文件系统都必须实现该接口），同时也是向上的接口（用户进
程通过系统调用最终能够访问文件系统功能）。


模块和热插拔
------------


模块用于在运行时动态地向内核添加功能，如设备驱动程序，文件系统，网络协议等，实
际上内核的任何子系统几乎都可以模块化。这消除了宏内核与微内核相比的一个缺陷。模
块还可以在运行时从内核卸载。

模块对于开发新功能的调试有很大的帮助，如果没有模块特性的话，为了添加和修改代码
后的新功能，要重新将这个宏内核编译一边，对于编译过内核的开发者来说，这多么的浪
费时间应该是不言而喻的。

模块的本质上不过是普通的程序，只是在内核空间而不是用户空间执行而已。模块必须提
供某些代码某些代码段在模块初始化（和终止）时执行，以便向内核注册和注销模块。另
外，模块代码与普通内核代码的权利（和义务）都是相同的，可以像编译到内核中的代码
一样，访问内核所有的函数和数据。

对于热插拔而言，模块在本质上是必需的。某些总线允许在系统运行时连接设备，而无需
系统重启。在系统检测到新设备时，通过加载对应的模块，可以将必要的驱动添加到内核
中。

模块特性使得内核可以支持种类繁多的设备，而内核自身的大小却不会发生膨胀。在检测
到连接的硬件后，只需要加载必要的模块，多余的驱动程序无需加入到内核。


==============================================================================
==============================================================================
