/****************************************
技巧22：SHA加密
安全哈希算法（secure hash algorithm）主要适用数字签名标准里面
定义的数字签名算法。
****************************************/

/****************************************
技巧23：MD5加密
MD5是一种被广泛使用的“消息-摘要算法”，实际上即使一个单项散列函数。
****************************************/

/****************************************
技巧24：RSA加密
RSA算法是非对称加密的代表。RSA算法是第一个同时用于加密和数字签名
的算法。
****************************************/

/****************************************
技巧25：DES加密
美国数据加密标准DES是一种对称加密算法。对称是指采用保密密玥既可
用于加密也可用于解密。
****************************************/

/****************************************
技巧26：RC4加密
RC4是可变的流加密算法簇。RC4算法包括初始化算法（KSA）和伪随即
子密码生成算法（PRGA）两大部分。
****************************************/

/****************************************
技巧29：迪杰斯特拉算法
其思想是：设置并逐步扩充一个集合S，存放已求出其最短路径的顶点，则
尚未确定路径的顶点集合是V-S，其中V为网中所有顶点集合。按最短路径
长度递增的顺序逐个将V-S中的顶点加到S中，直到S中包含全部顶点，而
V-S为空。
****************************************/
/*
#include <stdio.h>
#include <stdlib.h>
#define MAXNODE 30
#define MAXCOST 1000
int dist[MAXCOST],cost[MAXNODE][MAXNODE],n=5;
void dijkstra(int v0)  //自定义函数，用来求最小生成树
{
  int s[MAXNODE];             //定义一个集合s，其可扩充
  int mindis,dis,i,j,u;
  for (i=1; i<=n; i++)
    {
      dist[i]=cost[v0][i];
      s[i]=0;
    }
  s[v0]=1;
  for (i=1; i<=n; i++)
    {
      mindis=MAXCOST;
      for(j=1;j<=n;j++)
	if (s[j]==0&&dist[j]<mindis)
	  {
	    u=j;
	    mindis=dist[j];
	  }
      s[u]=1;
      for(j=1;j<=n;j++)
	if (s[j]==0)
	  {
	    dis=dist[u]+cost[u][j];
	    dist[j]=((dist[j]<dis)?dist[j]:dis);
	  }
    }
}
void display_path(int v0)     //自定义函数，用来输出到个顶点的最短路径
{
  int i;
  printf ("顶点%d到各个顶点的最短路径长度如下：\n",v0);
  for (i=1; i<=n; i++)
    {
      printf ("(v%d->v%d):",v0,i);
      if(dist[i]==MAXCOST)
	printf ("wu lu jing\n");
      else
	printf ("%d\n",dist[i]);
    }
}
main()
{
  int i,j,v0=1;
  for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
      cost[i][j]=MAXCOST;
  for(i=1;i<=n;i++)
    cost[i][i]=0;
  cost[1][2]=10;
  cost[1][5]=100;
  cost[1][4]=30;
  cost[2][3]=50;
  cost[4][3]=20;
  cost[3][5]=10;
  cost[4][5]=60;
  dijkstra(v0);
  display_path(v0);
  return 0;
}
*/

