5					0000 0101

39 				 0010 0111

137    			1000 1001



```
int main()
{
	
	return 0;
}
```

``SKIP``

<strong>ANGLE</strong>

***accleration***
$$
I = pv
$$

$$
I = F_\Delta t
$$

$$
p = mv
$$

$$
I = _\Delta{p}=mv_末 - mv_初
$$

$$
f\sum_{n = 1}^{n}
$$

<p style = "color:red;">
    LEVEL
</p>
<font color = "blue" >LEVEL</font>






$$
u(x)=kp(err(t)+\frac1T.\int err(t)dt+\frac{T_Dderr(t)}{dt})
$$


充电控制引脚

x,  y

x = 1,有USB插入

x = 0,无USB插入

y = 1,充满电

y = 0,充电中

| USB  | Charge |      状态       |
| :--: | :----: | :-------------: |
|  1   |   0    | USB插入，充电中 |
|  1   |   1    | USB插入，充满电 |
|  0   |   0    |    USB未插入    |
|  0   |   1    |    USB未插入    |



<a herf="https://www.baidu.com" title="百度">baidu</a>





安全灯亮度 60，频率同普闪

智能模式频率更改，周期2s, 亮100ms,灭1900ms

骑行模式抖光问题，优化或缩短爬坡时间为100ms,下坡600ms,高亮100ms,熄灭1200ms



C2滤波电容，VBUS+5V输出，

SMF静电二极管，

R2,R15分压给USB-IN，5V分压后大概2.5V，所以当有USB插入时，检测到高电平

然后作为EMC5755的输入，

CHGB作为检测充满电的引脚，充满电拉低，充电时拉高

PROG作为控制电压输出引脚，通过电阻的大小来改变提供的BAT引脚的电压

BAT引脚接LDO输入，作为SGM2306LDO电压输入，

LDO稳压电路，通过VIN引脚输入的电压，来稳定的输出电压，用以供给单片机供电。

一般输入比输出电压高于0.5~6VLDO即可稳定输出，这里LDO输出2.8V



COB电路

BAT电池供电作为ETA2421的VIN输入，之前用一个C5 10uF来滤波

EN-COB利用单片机PWM波输出，输出到CE引脚来使LX引脚输出正确的电压控制COB灯的亮度 

LX引脚接一个2.2UH和一个10uF的电容来进行滤波

电感过滤杂波，仅用一个电感效果并不好。所以多加了一个电容

FB是反馈引脚，LED的启动电压大于2V，压差0.7V，利用FB接一个电阻对其进行分压，来得到适合的电压



RT温敏电阻，温度升高，阻值降低

利用分压电路，一个温敏电阻，一个固定阻值电阻，接一个电容减缓电流，不至于突变

ADC采集电压电路

BAT电压输入，利用分压电路，ADC采集分压值，然后进行计算，同样接一个电容

光敏电阻也是同样的原理



PMOS管，低电平导通，S极接正，D极接负	

- 箭头向外

NMOS管，高电平导通，D极接正，S极接负

- 箭头向内
- NMOS管是压控型器件，Vgs电压大于Vth开启电压时，内部沟道在增强的作用下导通，Vgs电压小于Vth开启电压时，内部沟道截止；
- Vgs电压越高，内部电场越大，导通程度越高，导通电阻Ron越小，但需要注意，Vgs电压不能超过芯片允许的极限电压；
- NMOS管一般作为低端驱动器件，源极S接地

PNP

- 箭头向内

NPN

- 箭头向外

结型场效应管

增强型N沟道MOS管

增强型P沟道MOS管

耗尽型N沟道MOS管

增强型P沟道MOS管

滤波算法

1. ANL 	ORL	XRL	CLR	SETB	RL	RLC	RR	RRL	AND	OR	ADD	SUBB	MUL	DIV	INC	DEC	DA	#data	direct @Ri	MOV	MOVC	MOVX
2. AJMP   SJMP    LJMP    JMP    ACALL    ICALL    JZ    JNZ    CJNE    CJNZ    JC    JB    NOP  





GATT，利用<font color = "red">属性协议</font>定义了<font color = "red">服务框架</font>，方便client和service之间通过服务请求/响应建立通信。

通过属性来发现，读取，写入这些属性数据，一个服务有多个属性

Attributes（ATT定义的最小数据实体，也是构成GATT的service，characteristic，Descriptor的基本元素）

- handle
- value 
- permission
- type













GATT——通用属性配置文件层（Generic Attribute Profile）

利用属性协议来定义服务框架，方便client和service之间实现基于服务请求/响应的通信

GATT通过定义属性来发现，读取和写入这些属性数据，一个服务通常包含有多个属性

Client role:	发送服务，接收服务器的响应数据	

Server role:	响应服务，发送给客户端响应数据

- UUID 
  通用唯一标识符
  
- Attributes
  是ATT定义的数据最小实体，也是构成GATT的service，characteristic，descriptor的基本元素，每个Attribute都包含属性本身的信息和实际数据
  
  - Handle
  - Type
  - Value
  - Permissions
  
- GATT profile hierarchy

  - Profile
    - GATT定义的Profile由一个或多个Service组成
  - Service
    - 由一个或多个Characteristic构成，每个Service可以看做是完成特定功能或特定的数据或相关行为的集合
  - Characteristic
    - 每个Characteristic一般都包含一个数据或者一个公开行为，以及该数据的单位或者公开行为的的单位

- GATT feature and procedure
  GATT主要定义了11个功能，每个功能都映射到过程和子过程，这些过程和子过程描述了如何使用ATT来完成相应的功能

  - 

  

  



GATT

UUID

Attributes

handle

type

permission

value

service 

client



集显

- 集成在主板上，逐渐已经被淘汰

核显

- 集成在CPU上，一般够用

独显

- 独立的显卡，多用于游戏需求比较大

双显

- 核显和独显都有，自动调配

显卡



链表

typedef struct xxx

{

​	struct	xxx *next;

​	gattInfo_t	serviceInfo;

}serviceCBs_t;

结构体

属性封装成一个结构体

```
typedef struct attAttribute_t
{
	gattAttrType_t type;
	uint8 permission;
	uin16 handle
	uint8 * const pValue;
}gattAttribute_t;
```



osal 操作系统

非抢占，实时操作系统，大while循环



任务ID， 



SCL，SDA拉高



位段

```
struct name{
	unsigned int a:1;
	unsigned char b:3;
}Bit_Region;
```

```
srand((unsigned int)time(NULL));
int a = rand()%max+1;
```

链表

```
struct link{
	struct link * next;
	int elem;
}Link_l;
```

回调函数

共用体



ANL	ORL	XRL	CLR	SETB	RL	RLC	RR	RRC	ADD	SUBB	MUL	DIV	DV	INC	DEC

@Ri	direct	#data	A	MOV	MOVC	MOVX	AJMP	SJMP	LJMP	JMP	RET	RETI	ACALL	ICALL	JZ	JNZ	CJNE	CJNZ	JC	JB	NOP

​	

结构体中定义了函数指针，函数指针定义功能，函数参数可由枚举定义，然后利用条件判断函数参数来分别实现对应功能，函数嵌套使用，结构体成员赋值

结构体做函数参数，然后在函数内部对结构体成员分别判断，就是以结构体成员来判断分别执行不同操作。



结构体定义了指针数据成员，然后该结构体作函数参数，

在函数中，又有内存拷贝（osal_memcpy())，定义了一个全局二维数组，将结构体变量的指针数据通过内存拷贝给二维数组，其中长度又是以结构体中定义的长度成员来进行判断





GPIO读写

``` c
void hal_gpio_write(gpio_pin_e pin, uint8_t en)
{
	if(en)
    	AP_GPIO->swporta_dr |= BIT(pin);
    else
    	AP_GPIO->swporta_dr &= ~BIT(pin);
    hal_gpio_pin_init(pin,GPIO_OUTPUT);
}
bool hal_gpio_read(gpio_pin_e pin)
{
	uint32_t r;
	if(AP_GPIO->swporta_ddr & BIT(pin))
		r = AP_GPIO->swporta_dr;
	else
		r = AP_GPIO->ext_porta;
	return (int)((r >> pin)) & 1);
}

#define 	AP_GPIO		((AP_GPIO_TypeDef *)AP_GPIOA_BASE)
#define		AP_GPIOA_BASE	(AP_APB0_BASE + 0x8000)//gpio
#define 	BIT(n)		(1ul << (n))
typedef struct
{
	__IO uint32_t swporta_dr;		//0x00
	__IO uint32_t swporta_ddr;		//0x04
	...
	__IO uint32_t ext_porta;		//0x50
	...
}AP_GPIO_TypeDef;
```



PWM通道，使能，状态，用结构体定义

```
typedef struct 
{
	bool  enable;
	bool  ch_en[6];
	pwm_ch_t	ch[6];
}pwm_Ctx_t;
```



0x04

<p>
    <h3>
        霍尔效应
        </h3>
</p>
导体或半导体位于磁场中，且磁场方向与电流方向垂直。在磁场中，电子收到洛伦兹力的作用，根据左手定则判断洛伦兹力的方向
$$
F_L = eBv
$$


洛伦兹力会使电子向内偏移，由此形成底层自由电子集合，上层表面空穴集结，产生内电场，产生电动势，称为霍尔电压，与洛伦兹力方向相反。当达到动态平衡后，
$$
F_H = F_L
$$

$$
eE_H = eBv		\\
E_H = Bv
$$

$$
U_H = E_Hb = Bvb
$$



电流等于电子流过单位横截面面积的电荷量，电子浓度为n，电子移动平均速度为v，板宽b，厚度为d，N型半导体自由电子参与导电，与电流方向相反，P型半导体空穴参与导电，与电流方向相同
$$
N型半导体\\
I = -nevbd \\
P型半导体	\\
I = nevbd
$$

$$
U_H = -\frac{IB}{ned}
$$

$$
R_H = -\frac{I}{ne}   \\
R_H霍尔系数
$$

$$
K_H = -\frac{I}{ned}   \\
K_H 霍尔灵敏度
$$



1010   0000  1100

1010    1111  1000

PID

比例，积分，微分

Proportion	Integral	Differential

闭环控制（有反馈）
$$
u(t)=K_pe(t)+K_i\int_0^te(\tau)d\tau+K_d{\frac{de(t)}{dt}}      \\
K_p是比例增益，K_i是积分增益，K_d是微分增益
$$
对上式进行离散化，假设采样系统时间▲t，则将输入e(t)序列化得到

位置式PID
$$
u(k) = K_pe_k + K_i\sum_{i=1}^ke(i)\Delta t+K_d\frac{e(k)-e(k-1)}{\Delta t}
$$

$$
通过\Delta u(k) = u(k) - u(k-1) 可得到增量式PID
$$



增量式PID
$$
\Delta u(k) = K_p(e(k)-e(k-1))+K_ie(k)+K_d(e(k)-2e(k-1)+e(k-2))
$$


GAP

- 通用访问协议
  - 模式和过程
    - 
  - role
    - 外围
    - 中心
    - 广播
    - 观察

GATT

ATT

L2CAP

LL



```c
hal_pwm_init();
hal_pwm_set_count_val();
hal_pwm_open_channel();
hal_pwm_close_channel();
hal_pwm_start();
hal_pwm_destroy();
hal_pwm_stop();
hal_pwm_module_init();
hal_pwm_module_deinit();
hal_pwm_ch_start();
hal_pwm_ch_stop();
hal_pwm_ch_enable();
hal_pwm_ch_reg();
```

```c
hal_gpio_init();
hao_gpio_pin_init();
hal_gpioin_enable();
hal_gpioin_register();
hal_gpioin_unregister();
hao_gpio_pull_set();
hal_gpio_write();
hal_gpio_read();
hal_gpio_fmux_set();
hal_gpio_fmux();
hal_gpio_wakeup_set();
```

```c
hal_uart_init();
hal_uart_deinit();
hal_uart_set_tx_buf();
hal_uart_get_tx_ready();
hal_uart_send_buff();
hal_uart_send_byte();
uart_hw_init();
uart_hw_deinit();
txmit_buf_polling();
txmit_buf_use_tx_buf();
```



放大：按比例放大，变化前后能量守恒

放大倍数：Xo : Xi 

通频带：对不同放大电路的放大作用范围

上限截止频率FH，下限截止频率FL	Fbw = FH - FL

开漏：NMOS管 0 ，PMOS管高阻态

推挽：NMOS管 0，PMOS管 1





更新广播数据

1. 获取新的设置从GATT属性
2. 更新广播数据存储
   1. 设置UUID
   2. 设置major
   3. 设置minor
   4. 断开所有连接
   5. 关闭广播
   6. 更新广播数据
      1. 更新广播类型
      2. 更新广告播出
      3. 设置发射功率，RF PHY TX POWER
   7. 设置复位广播实践，提示GAP/LL 会处理关闭广播事件
      `osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_RESET_ADV_EVT,5000)`



# 1

dio:人类的能力是有极限的，人越是工于计谋，计谋就越会因为意想不到的事情而失败，除非成为超越人类的存在。

jo:你到底想说什么？dio

dio：おれは人间をやめるぞ！　ジョジョ──ッ！！





<a name="jump">jump</a>

<span id="haha"> </span>

## 1.1

PWM占空比精度

1：100

1：1000

占空比：高电平占整个周期的时间比值

PWM周期与PWM频率

边沿对齐方式

（PWMPH，PWMPL）周期设定寄存器
$$
F_{pwm} = \frac {F_{clk}}{PWMDIV}
$$

$$
PWM频率 = \frac {F_{pwm}}{(PWMPH,PWMPL)+1}
$$



<a name="位置1">位置1</a>



[ADC](#1)



[pwm](##1.1)







[点击跳转](#haha)

<div id="hei"></div>











<a href="#位置1">点击到位置1</a>

<a href="#jump">click</a>

[click](#jump)







函数指针数组

函数指针

函数多个参数

结构体做参数，结构体嵌套结构体







结构体成员是函数指针变量

结构体定义变量并赋值

函数指针函数定义

函数里包含多个参数，其中也有结构体变量

结构体变量包含多个成员，还嵌套了另一个结构体





宏定义来实现对指针变量的高低位读取



```c
#define BUILD_UINT16(*loByte*, *hiByte*)  ((uint16)(((loByte) & 0x00FF) + (((hiByte) & 0x00FF) << 8)))

#define HI_UINT16(a) (((a) >> 8) & 0xFF)
#define LO_UINT16(a) ((a) & 0xFF)
```





在一个函数中，同过对参数的判断，然后来将全局数据（可以变量，数组，结构体等）的状态来进行操作改变。然后在其他地方通过函数来对这个数据执行对应的功能











> ```c
> /* sbpProfile_ota.c  */
> CONST uint8 simpleProfileServUUID[ATT_BT_UUID_SIZE] =
> {
>     LO_UINT16(SIMPLEPROFILE_SERV_UUID), HI_UINT16(SIMPLEPROFILE_SERV_UUID)
> };
> 
> // Simple Profile Service attribute
> static CONST gattAttrType_t simpleProfileService = { ATT_BT_UUID_SIZE, simpleProfileServUUID };
> 
> static gattAttribute_t simpleProfileAttrTbl[] =
> {
>     // Simple Profile Service
>     {
>         { ATT_BT_UUID_SIZE, primaryServiceUUID }, /* type */
>         GATT_PERMIT_READ,                         /* permissions */
>         0,                                        /* handle */
>         (uint8*)& simpleProfileService            /* pValue */
>     },
>     
>     ...
> };
> 
> static uint8 simpleProfile_ReadAttrCB( uint16 connHandle, gattAttribute_t* pAttr,uint8* pValue, uint16* pLen, uint16 offset, uint8 maxLen );
> 
> static bStatus_t simpleProfile_WriteAttrCB( uint16 connHandle, gattAttribute_t* pAttr,uint8* pValue, uint16 len, uint16 offset );
> 
> // Simple Profile Service Callbacks
> CONST gattServiceCBs_t simpleProfileCBs =
> {
>     simpleProfile_ReadAttrCB,  // Read callback function pointer
>     simpleProfile_WriteAttrCB, // Write callback function pointer
>     NULL                       // Authorization callback function pointer
> };
> 
> 
> status = GATTServApp_RegisterService( simpleProfileAttrTbl,GATT_NUM_ATTRS( simpleProfileAttrTbl ),&simpleProfileCBs );
> ```
>
> 



